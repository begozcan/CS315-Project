// Declare the tokens
%expect 2
%token LOWERCASE
%token UPPERCASE
%token LETTER
%token DIGIT
%token LPARAN
%token RPARAN
%token LBRACK
%token RBRACK
%token LCURLY
%token RCURLY
%token COMMA
%token COL
%token PERCENT

%token CARET
%token DCARET

%token PP
%token SP

%token NEWLINE

%token INTEGER_TOKEN
%token FLOAT_TOKEN
%token STRING_TOKEN

%token ID

%token ASSIGNMENT
%token INSERT
%token REMOVE

%token LESS
%token GREATER
%token LESSEQUAL
%token GREATEREQUAL
%token EQUAL
%token NOTEQUAL
%token NOT

//%right NOT

%token CONCAT
%token ALTER
%token REP
%token ALL

//%left REP
//%left CONCAT
//%left ALTER

%token INTDECLARATION
%token FLOATDECLARATION
%token STRINGDECLARATION
%token BOOLEANDECLARATION

%token PAIRDECLARATION
%token LISTDECLARATION
%token MAPDECLARATION
%token SETDECLARATION

%token POINTDECLARATION
%token ONEWAYSTREETDECLARATION
%token TWOWAYSTREETDECLARATION

%token ONEWAYSTREETNETWORKDECLARATION
%token TWOWAYSTREETNETWORKDECLARATION

%token FINDROUTE
%token SORT
%token LIMIT

%token LIMITORS

%token BOOLEANTRUE
%token BOOLEANFALSE

%token ERROR_CHAR
%token SETINDICATOR

%union
{
  char * string;
  int integer;
  float fp;
}

%{
    #include <unordered_map>
    #include <iostream>
    using namespace std;
    // forward declarations
    void yyerror(char *);
    int yylex(void);
    // symbol table to hold variable values
    unordered_map<string, int> symbols;
    %}

%%

STMT: error {cerr << "Error at Statement level" << endl;} | {cout << "FINISHED" << endl;} | EXPR NEWLINE STMT;

EXPR: | error {cerr << "Error at Expression level" << endl;} | QUERYMAP | LIST | PAIR | INTEGER | FLOAT
| STRING | BOOLEAN | FINDROUTEGR |  MODIFYQUERY;

// DECLARATIONS
LIST: LISTDECLARATION ID LISTTAIL;

QUERYMAP: MAPDECLARATION ID QUERYMAPTAIL;

FINDROUTEGR: LISTDECLARATION ID FUNCTAILS;

PAIR: PAIRDECLARATION ID PAIRTAIL;

INTEGER: INTDECLARATION ID INTTAIL;

FLOAT: FLOATDECLARATION ID FLOATTAIL;

STRING: STRINGDECLARATION ID STRINGTAIL;

BOOLEAN: BOOLEANDECLARATION ID BOOLTAIL;

MODIFYQUERY: ID FUNCTAILS;

// TAILS

FUNCTAILS: FINDROUTETAIL | FINDROUTETAIL SORT LPARAN LIMITORS RPARAN | FINDROUTETAIL LIMIT LPARAN LIMITORS COMMA ID RPARAN
| FINDROUTETAIL LIMIT LPARAN LIMITORS COMMA INTEGER_TOKEN RPARAN | ASSIGNMENT ID SORT LPARAN LIMITORS RPARAN | ASSIGNMENT ID LIMIT LPARAN LIMITORS COMMA ID RPARAN
| ASSIGNMENT ID LIMIT LPARAN LIMITORS COMMA INTEGER_TOKEN RPARAN ;

LISTTAIL: | ASSIGNMENT LIST_TOKEN;

LIST_TOKEN: LCURLY DATA LISTBODY RCURLY;

LISTBODY: error {cerr << "Error at List Body level" << endl;} | COMMA DATA LISTBODY;

FINDROUTETAIL: ASSIGNMENT ID FINDROUTE LPARAN FRPARAM RPARAN;

QUERYMAPTAIL: | error {cerr << "Error at Query Map level" << endl;} | ASSIGNMENT QUERYMAP_TOKEN;

QUERYMAP_TOKEN: LBRACK MAPBODY COMMA MAPBODY MAPTAIL RBRACK;

MAPTAIL: | error {cerr << "Error at Map Tail level" << endl;} | COMMA MAPBODY;

MAPBODY: error {cerr << "Error at Map Body level" << endl;} |PAIR_TOKEN | ID;

PAIRTAIL: | error {cerr << "Error at Pair Tail level" << endl;} | ASSIGNMENT PAIR_TOKEN;

PAIR_TOKEN: LPARAN STRING_TOKEN COMMA QUERYDATA RPARAN;

INTTAIL: | error {cerr << "Error at Int Tail level" << endl;} | ASSIGNMENT INTEGER_TOKEN;

FLOATTAIL: | error {cerr << "Error at Float Tail level" << endl;} | ASSIGNMENT FLOAT_TOKEN;

STRINGTAIL: | error {cerr << "Error at String Tail level" << endl;} | ASSIGNMENT STRING_TOKEN;

BOOLTAIL: | error {cerr << "Error at Boolean Tail level" << endl;} | ASSIGNMENT BOOLEANTRUE | ASSIGNMENT BOOLEANFALSE;

// TERMINALS

FRPARAM: ID | QUERYMAP_TOKEN;

QUERYDATA: QUERYDATATAIL BOOLOP QUERYDATA | QUERYDATATAIL;

QUERYDATATAIL: BOOLS | PERCENT BOOLS PERCENT;

BOOLS: BOOLS BOOLOP BOOLEXP  | BOOLEXP ;

BOOLEXP: NOT BOOLEXP | BOOLEXPTAIL;

BOOLEXPTAIL: CARET ID LBRACK DATA RBRACK REPTOKEN| DCARET ID LBRACK DATA RBRACK REPTOKEN
| PP LBRACK DATA RBRACK RETRIBOOL COMP DATA REPTOKEN | SP LBRACK DATA RBRACK RETRIBOOL COMP DATA REPTOKEN;

RETRIBOOL: | LBRACK RETRIEVALBODY RBRACK;

DATA:INTEGER_TOKEN | STRING_TOKEN | FLOAT_TOKEN | BOOLEANTRUE
| BOOLEANFALSE | PAIR_TOKEN | LIST_TOKEN | QUERYMAP_TOKEN | ID;

RETRIEVALBODY: error {cerr << "Error at Retrival Body level" << endl;} |STRING_TOKEN | INTEGER_TOKEN | INTEGER_TOKEN COL INTEGER_TOKEN;

BOOLOP: CONCAT  | ALTER;

REPTOKEN: | REP ALL  | REP INTEGER_TOKEN;

COMP: error {cerr << "Error at Comparision level" << endl;} |LESS | GREATER | LESSEQUAL | GREATEREQUAL | EQUAL | NOTEQUAL;
%%
// report errors

void yyerror(char *s)
{
    cerr << s << endl;
}
